const pool = require("../database/index");
const jwt = require("jsonwebtoken");
const sharp = require("sharp");

const eventController = {
  authenticateToken: (req, res, next) => {
    const authHeader = req.headers["authorization"];
    const token = authHeader && authHeader.split(" ")[1];
    if (!token) return res.status(401).json({ error: "Kein Token bereitgestellt." });

    jwt.verify(token, "secretKey", (err, user) => {
      if (err) return res.status(403).json({ error: "Ungültiger Token." });
      req.user = user;
      next();
    });
  },

  createEvent: async (req, res) => {
    let connection;
    try {
      if (!req.user.userTypes || !req.user.userTypes.includes("vorstand")) {
        return res
          .status(403)
          .json({ error: "Nur Benutzer mit Vorstandrechten dürfen ein Event erstellen." });
      }

      const {
        titel,
        beschreibung,
        ort,
        von,
        bis,
        alle,
        supporter,
        bildtitel,
        preise,
        bild,
      } = req.body;

      if (!titel || !beschreibung || !ort || !von || !bis) {
        return res
          .status(400)
          .json({ error: "Titel, Beschreibung, Ort, Von und Bis müssen angegeben werden." });
      }

      // Bild prüfen & konvertieren
      let base64Bild = null;
      if (bild) {
        const matches = bild.match(/^data:(image\/[a-zA-Z]+);base64,(.+)$/);
        if (!matches || matches.length !== 3) {
          return res.status(400).json({
            error: "Ungültiges Bildformat. Erwarte Base64-String mit data:image/... Prefix.",
          });
        }

        const mimeType = matches[1];
        const base64Data = matches[2];
        const buffer = Buffer.from(base64Data, "base64");

        if (!["image/png", "image/jpeg", "image/jpg", "image/webp"].includes(mimeType)) {
          return res.status(400).json({ error: "Nur PNG, JPEG, JPG oder WEBP erlaubt." });
        }

        const convertedBuffer = await sharp(buffer).png().toBuffer();
        base64Bild = convertedBuffer.toString("base64");
      }

      connection = await pool.getConnection();
      await connection.beginTransaction();

      // Event speichern (immer mit Status = aktiv)
      const [eventResult] = await connection.query(
        `INSERT INTO events (titel, beschreibung, ort, von, bis, bild, bildtitel, supporter, alle, status)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'aktiv')`,
        [titel, beschreibung, ort, von, bis, base64Bild, bildtitel || null, supporter || null, alle ? 1 : 0]
      );

      const eventId = eventResult.insertId;

      // Preise hinzufügen
      if (Array.isArray(preise) && preise.length > 0) {
        const preisWerte = preise
          .filter((p) => p.preisbeschreibung && p.kosten != null)
          .map((p) => [eventId, p.preisbeschreibung, p.kosten]);

        if (preisWerte.length > 0) {
          await connection.query(
            `INSERT INTO event_preise (event_id, preisbeschreibung, kosten) VALUES ?`,
            [preisWerte]
          );
        }
      }

      await connection.commit();
      res.status(201).json({ message: "Event erfolgreich erstellt." });
    } catch (error) {
      if (connection) {
        try {
          await connection.rollback();
        } catch {}
        connection.release();
      }
      console.error("Fehler beim Erstellen des Events:", error);
      res.status(500).json({ error: "Fehler beim Erstellen des Events." });
    } finally {
      if (connection) connection.release();
    }
  },

  getEvents: async (req, res) => {
    try {
      // Abgelaufene Events automatisch beenden
      await pool.query(`UPDATE events SET status = 'beendet' WHERE bis < NOW() AND status = 'aktiv'`);

      const [events] = await pool.query(
        `
        SELECT e.id, e.titel, e.beschreibung, e.ort, e.von, e.bis, e.status, e.bild, e.alle, e.supporter,
               p.id as preis_id, p.preisbeschreibung, p.kosten
        FROM events e
        LEFT JOIN event_preise p ON e.id = p.event_id
        ORDER BY e.von DESC
      `
      );

      const grouped = {};
      for (const row of events) {
        if (!grouped[row.id]) {
          grouped[row.id] = {
            id: row.id,
            titel: row.titel,
            beschreibung: row.beschreibung,
            ort: row.ort,
            von: row.von,
            bis: row.bis,
            status: row.status,
            bild: row.bild ? `data:image/png;base64,${row.bild}` : null,
            alle: !!row.alle,
            supporter: !!row.supporter,
            preise: [],
          };
        }

        if (row.preis_id) {
          grouped[row.id].preise.push({
            id: row.preis_id,
            preisbeschreibung: row.preisbeschreibung,
            kosten: row.kosten,
          });
        }
      }

      res.status(200).json(Object.values(grouped));
    } catch (error) {
      console.error("Fehler beim Abrufen der Events:", error);
      res.status(500).json({ error: "Fehler beim Abrufen der Events." });
    }
  },

  getEventById: async (req, res) => {
    try {
      const eventId = req.params.id;

      // Prüfen ob Event abgelaufen ist → automatisch beenden
      await pool.query(
        `UPDATE events SET status = 'beendet' WHERE bis < NOW() AND id = ? AND status = 'aktiv'`,
        [eventId]
      );

      const [events] = await pool.query(
        `
        SELECT e.id, e.titel, e.beschreibung, e.ort, e.von, e.bis, e.status, e.bild, e.alle, e.supporter,
               p.id as preis_id, p.preisbeschreibung, p.kosten
        FROM events e
        LEFT JOIN event_preise p ON e.id = p.event_id
        WHERE e.id = ?
      `,
        [eventId]
      );

      if (events.length === 0) {
        return res.status(404).json({ error: "Event nicht gefunden." });
      }

      const event = {
        id: events[0].id,
        titel: events[0].titel,
        beschreibung: events[0].beschreibung,
        ort: events[0].ort,
        von: events[0].von,
        bis: events[0].bis,
        status: events[0].status,
        bild: events[0].bild ? `data:image/png;base64,${events[0].bild}` : null,
        alle: !!events[0].alle,
        supporter: !!events[0].supporter,
        preise: [],
      };

      for (const row of events) {
        if (row.preis_id) {
          event.preise.push({
            id: row.preis_id,
            preisbeschreibung: row.preisbeschreibung,
            kosten: row.kosten,
          });
        }
      }

      res.status(200).json(event);
    } catch (error) {
      console.error("Fehler beim Abrufen des Events:", error);
      res.status(500).json({ error: "Fehler beim Abrufen des Events." });
    }
  },

  updateEvent: async (req, res) => {
    try {
      if (!req.user.userTypes || !req.user.userTypes.includes("vorstand")) {
        return res.status(403).json({ error: "Nur Vorstand darf Events bearbeiten." });
      }

      const eventId = req.params.id;
      const { titel, beschreibung, ort, von, bis, alle, supporter, status } = req.body;

      let bildBase64 = null;
      if (req.body.bild) {
        if (!req.body.bild.startsWith("data:image/png;base64,")) {
          return res
            .status(400)
            .json({ error: "Bild muss als PNG im Base64-Format mit Prefix gesendet werden." });
        }
        bildBase64 = req.body.bild.replace(/^data:image\/png;base64,/, "");
      }

      let sql = `UPDATE events SET titel = ?, beschreibung = ?, ort = ?, von = ?, bis = ?, alle = ?, supporter = ?`;
      let params = [titel, beschreibung, ort, von, bis, alle ? 1 : 0, supporter ? 1 : 0];

      if (bildBase64 !== null) {
        sql += `, bild = ?`;
        params.push(bildBase64);
      }

      if (status) {
        sql += `, status = ?`;
        params.push(status);
      }

      sql += ` WHERE id = ?`;
      params.push(eventId);

      await pool.query(sql, params);

      res.status(200).json({ message: "Event erfolgreich aktualisiert." });
    } catch (error) {
      console.error("Fehler beim Aktualisieren des Events:", error);
      res.status(500).json({ error: "Fehler beim Aktualisieren des Events." });
    }
  },

  deleteEvent: async (req, res) => {
    try {
      if (!req.user.userTypes || !req.user.userTypes.includes("vorstand")) {
        return res.status(403).json({ error: "Nur Vorstand darf Events löschen." });
      }

      const eventId = req.params.id;
      await pool.query(`DELETE FROM events WHERE id = ?`, [eventId]);

      res.status(200).json({ message: "Event erfolgreich gelöscht." });
    } catch (error) {
      console.error("Fehler beim Löschen des Events:", error);
      res.status(500).json({ error: "Fehler beim Löschen des Events." });
    }
  },

  createFormFields: async (req, res) => {
    try {
      if (!req.user.userTypes || !req.user.userTypes.includes("vorstand")) {
        return res.status(403).json({ error: "Nur Vorstand darf Formulare erstellen." });
      }

      const { eventId, felder } = req.body;

      if (!eventId || !Array.isArray(felder)) {
        return res.status(400).json({ error: "Event-ID und Felder müssen angegeben werden." });
      }

      await pool.query(`DELETE FROM event_formulare WHERE event_id = ?`, [eventId]);

      if (felder.length > 0) {
        const werte = felder.map((f) => [eventId, f.feldname, f.typ || "text", f.pflicht ? 1 : 0]);
        await pool.query(
          `INSERT INTO event_formulare (event_id, feldname, typ, pflicht) VALUES ?`,
          [werte]
        );
      }

      res.status(201).json({ message: "Formular erfolgreich erstellt." });
    } catch (error) {
      console.error("Fehler beim Erstellen des Formulars:", error);
      res.status(500).json({ error: "Fehler beim Erstellen des Formulars." });
    }
  },

  getFormFields: async (req, res) => {
    try {
      const eventId = req.params.id;
      const [felder] = await pool.query(
        `SELECT id, feldname, typ, pflicht FROM event_formulare WHERE event_id = ?`,
        [eventId]
      );
      res.status(200).json(felder);
    } catch (error) {
      console.error("Fehler beim Laden des Formulars:", error);
      res.status(500).json({ error: "Fehler beim Laden des Formulars." });
    }
  },

  registerForEvent: async (req, res) => {
    try {
      const eventId = req.params.id;
      const { vorname, nachname, daten } = req.body;

      if (!vorname || !nachname) {
        return res.status(400).json({ error: "Vorname und Nachname sind Pflichtfelder." });
      }

      const [felder] = await pool.query(
        `SELECT feldname, pflicht FROM event_formulare WHERE event_id = ?`,
        [eventId]
      );

      for (const feld of felder) {
        if (feld.pflicht && (!daten || !daten[feld.feldname])) {
          return res.status(400).json({ error: `Pflichtfeld fehlt: ${feld.feldname}` });
        }
      }

      await pool.query(
        `INSERT INTO event_anmeldungen (event_id, vorname, nachname, daten) VALUES (?, ?, ?, ?)`,
        [eventId, vorname, nachname, JSON.stringify(daten || {})]
      );

      res.status(201).json({ message: "Anmeldung erfolgreich gespeichert." });
    } catch (error) {
      console.error("Fehler bei der Anmeldung:", error);
      res.status(500).json({ error: "Fehler bei der Anmeldung." });
    }
  },

  getRegistrations: async (req, res) => {
    try {
      if (!req.user.userTypes || !req.user.userTypes.includes("vorstand")) {
        return res.status(403).json({ error: "Nur Vorstand darf Anmeldungen sehen." });
      }

      const eventId = req.params.id;
      const [rows] = await pool.query(
        `SELECT id, vorname, nachname, daten, created_at FROM event_anmeldungen WHERE event_id = ?`,
        [eventId]
      );

      const result = rows.map((r) => ({
        id: r.id,
        vorname: r.vorname,
        nachname: r.nachname,
        daten: JSON.parse(r.daten || "{}"),
        created_at: r.created_at,
      }));

      res.status(200).json(result);
    } catch (error) {
      console.error("Fehler beim Abrufen der Anmeldungen:", error);
      res.status(500).json({ error: "Fehler beim Abrufen der Anmeldungen." });
    }
  },

  // In deinem eventController
getNextEventId: async (req, res) => {
  try {
    const [rows] = await pool.query(
      `SELECT AUTO_INCREMENT as nextId
       FROM information_schema.TABLES
       WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'events'`
    );
    res.status(200).json({ nextId: rows[0].nextId });
  } catch (error) {
    console.error("Fehler beim Holen der nächsten Event-ID:", error);
    res.status(500).json({ error: "Fehler beim Holen der nächsten Event-ID." });
  }
},

};

module.exports = eventController;





// Formulare
router.post("/:id/formular", eventController.authenticateToken, eventController.createFormFields);
router.get("/:id/formular", eventController.getFormFields);

// Anmeldung
router.post("/:id/anmelden", eventController.registerForEvent);
router.get("/:id/anmeldungen", eventController.authenticateToken, eventController.getRegistrations);





const pool = require("../database/index");
const nodemailer = require("nodemailer");
const axios = require("axios");

const transporter = nodemailer.createTransport({
  host: "mail.hostpoint.ch",
  port: 587,
  secure: false, // STARTTLS
  auth: {
    user: "info@jugehoerig.ch",
    pass: "antoinette97!juge",
  },
  tls: {
    rejectUnauthorized: false,
  },
});

// SMTP Test
const testSmtpConnection = async (req, res) => {
  try {
    await transporter.verify();
    res.status(200).json({ message: "SMTP-Verbindung erfolgreich hergestellt." });
  } catch (error) {
    console.error("SMTP-Verbindung fehlgeschlagen:", error);
    res.status(500).json({
      error: "SMTP-Verbindung fehlgeschlagen.",
      details: error.message,
    });
  }
};

const anfrageController = {
  testSmtpConnection,

  createAnfrage: async (req, res) => {
    const { name, email, nachricht } = req.body;

    if (!name || !email || !nachricht) {
      return res
        .status(400)
        .json({ error: "Name, Email und Nachricht sind Pflichtfelder." });
    }

    try {
      // 1️⃣ Anfrage speichern
      const [result] = await pool.query(
        "INSERT INTO anfragen (name, email, nachricht, erstellt_am) VALUES (?, ?, ?, NOW())",
        [name, email, nachricht]
      );
      const anfrageId = result.insertId;

      // 2️⃣ Logo holen
      const logoRes = await axios.get(
        "https://jugehoerig-backend.onrender.com/api/logo"
      );
      const logoUrl = logoRes.data.logoUrl;

      // 3️⃣ Mail an Admin
      const mailAnInfo = {
        from: '"Jugehörig System" <info@jugehoerig.ch>',
        to: "info@jugehoerig.ch",
        subject: `Neue Anfrage von ${name}`,
        replyTo: email,
        html: `
          <div style="font-family:Arial,sans-serif; padding:20px; background:#f9f9f9;">
            <div style="max-width:600px; margin:0 auto; background:#fff; border-radius:10px; overflow:hidden;">
              <div style="background:#F59422; padding:20px; text-align:center;">
                <img src="${logoUrl}" alt="Logo" style="height:50px;">
              </div>
              <div style="padding:30px; color:#333;">
                <h2 style="color:#F59422;">Neue Anfrage erhalten</h2>
                <ul>
                  <li><strong>Name:</strong> ${name}</li>
                  <li><strong>Email:</strong> ${email}</li>
                  <li><strong>Nachricht:</strong> ${nachricht}</li>
                </ul>
                <div style="margin-top:20px; text-align:center;">
                  <a href="https://deine-domain.ch/admin/anfragen/${anfrageId}" 
                     style="background:#F59422; color:#fff; padding:12px 25px; border-radius:5px; text-decoration:none;">Anfrage ansehen</a>
                </div>
              </div>
              <div style="background:#f1f1f1; padding:20px; text-align:center; font-size:12px; color:#666;">
                &copy; ${new Date().getFullYear()} Jugehörig
              </div>
            </div>
          </div>
        `,
      };

      // 4️⃣ Mail an Kunde
      const mailAnKunde = {
        from: '"Jugehörig Website" <info@jugehoerig.ch>',
        to: email,
        subject: "Ihre Anfrage wurde erfolgreich eingereicht",
        replyTo: "info@jugehoerig.ch",
        html: `
          <div style="font-family:Arial,sans-serif; padding:20px; background:#f9f9f9;">
            <div style="max-width:600px; margin:0 auto; background:#fff; border-radius:10px; overflow:hidden;">
              <div style="background:#F59422; padding:20px; text-align:center;">
                <img src="${logoUrl}" alt="Logo" style="height:50px;">
              </div>
              <div style="padding:30px; color:#333;">
                <h2 style="color:#F59422;">Hallo ${name},</h2>
                <p>Vielen Dank für Ihre Anfrage! Wir melden uns so schnell wie möglich bei Ihnen.</p>
                <p><strong>Ihre Nachricht:</strong></p>
                <blockquote style="border-left:4px solid #F59422; padding-left:15px; color:#555;">${nachricht}</blockquote>
              </div>
              <div style="background:#f1f1f1; padding:15px; text-align:center; font-size:12px; color:#666;">
                Bitte antworten Sie <strong>nicht</strong> auf diese E-Mail. Für Anliegen schreiben Sie bitte an: <strong>info@jugehoerig.ch</strong>.
              </div>
              <div style="background:#f1f1f1; padding:20px; text-align:center; font-size:12px; color:#666;">
                &copy; ${new Date().getFullYear()} Jugehörig
              </div>
            </div>
          </div>
        `,
      };

      // 5️⃣ Senden
      await transporter.sendMail(mailAnInfo);
      await transporter.sendMail(mailAnKunde);

      return res.status(201).json({
        message: "Anfrage erfolgreich gespeichert und E-Mails verschickt.",
        anfrageId,
      });
    } catch (err) {
      console.error("Fehler beim Erstellen der Anfrage:", err);
      return res
        .status(500)
        .json({ error: "Fehler beim Verarbeiten der Anfrage." });
    }
  },

  getAnfragen: async (req, res) => {
    try {
      const [rows] = await pool.query(
        "SELECT * FROM anfragen ORDER BY erstellt_am DESC"
      );
      res.json(rows);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "Fehler beim Abrufen der Anfragen." });
    }
  },

  getAnfrageById: async (req, res) => {
    const { id } = req.params;
    try {
      const [rows] = await pool.query("SELECT * FROM anfragen WHERE id=?", [id]);
      if (!rows.length)
        return res.status(404).json({ error: "Anfrage nicht gefunden." });
      res.json(rows[0]);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "Fehler beim Abrufen der Anfrage." });
    }
  },
};

module.exports = anfrageController;
